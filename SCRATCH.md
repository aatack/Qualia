- A component is given a completely unregulated "workspace"
- When some part of the global workspace changes, the component is asked to update its workspace
- The function for doing this looks something like `(update [workspace context arguments paths-in paths-out] ...)`
- This extremely general wrapper should allow you to write heavily optimised components if you really want to
- Most typical components should - hopefully - become quite simple under this paradigm
- We could impose some structure upon the returned workspace to standardise some common optimisations
- For example, if the workspace always contains `:arguments`, `:state`, and `:consumed` forms, and there's no global state (only provided state), you know that you don't need to do any updates at all if:
  - All arguments are the same
  - All of your consumed paths, and those of your children, diverge from all of the updated paths
    - Is this horrendously difficult to check, computationally?
    - Because there'll probably be lots of nice branching behaviour, seems like it'd be pretty easy to check if we really wanted to find an optimised way of writing it (with some custom algorithm)
  - Also, at each stage you can cull the dictionary of changed paths according to the dictionary of consumed paths, which makes future checks (further down the line) easier
- The output of the update method should be a series of path-value pairs, which are used by the framework to update its state atom externally
  - This also means that callers of child components can determine whether or not they need to update any of their keys, or whether they can just return the update as-is
- Another nice thing is that the entire tree - including all globally- and locally-managed state - can be viewed as a single clojure object, with no extra bells or whistles
- Finally, it would be easy to come up with some heuristic to work out when to "collapse" the tree of dependencies
  - Eg. if a component is listening to the paths `[:state :text]`, `[:state :history :1]`, and `[:state :start]`, it might make sense to collapse that to just `[:state]` to reduce the complexity of checks
  - If you wanted to impose a little more structure, you could say that you're going to represent paths with two components: the component path and the state path. Then you'd know that you don't ever need to consider any updates that have diverging component paths, since there's no way for a component to affect another that isn't in the same branch
    - Though I don't like this as much because it's kind of cool that the state of a children of a component exist exclusively inside its workspace, and aren't in any way special; they're the same as any other state in the tree
- Obviously you'd need a bunch of wrappers around all of this to make it usable anyway
- Another cool thing is that you really can go all the way on the "events as state" train, even for impulse events like clicks and key presses
  - You'd just make sure there's a "key press" path, and every time it gets an updated signal you assume its current value is the key pressed
  - To save on rendering time, if multiple come through at once you could send down the events without a `:render` request in the `paths-out`, so highly-optimised components could even avoid rendering themselves until actually requested if they really wanted to
  - One important convention for this to actually work: any values of `nil` in the returned mapping (paths out) must always be interpreted as "computed lazily; must be requested specifically to obtain a value"
- [ ] A conundrum: if the mouse position is to be constantly in the state, and always updated, it mustn't trigger spurious updates whenever it moves
  - This means that components need to be able to say whether they use the mouse status, to prevent common components like `translate` from having to continually update the mouse position when their children are uninterested in the mouse position
  - Crucially, you need to know whether to compute the new translated mouse position before rendering any children (as you need to build the context); but you don't know whether or not the child is consuming the mouse position until after it's been rendered - and hence until after you've already computed the new position
  - I'm sure you could probably come up with a contrived example where the child becomes dependent on the mouse position suddenly, as a result of a change in some other variable
    - Actually I don't even think it would need to be all that contrived...
  - [ ] Are lazy contexts the way to solve this?
    - Importantly: while I suspect it's possible for a child component to start caring about whether the mouse position _will change_ spontaneously, I don't think it's possible for it to suddenly start caring about whether it _has changed_, since it didn't know what the previous value was in the first place
- It's interesting to note that literally none of this is UI-specific - at least, not in its most general case
  - Surely this is reinventing some wheel somewhere?
  - I suppose what it really is is a way of laying out the classic observer architecture in a way that (sort of?) guarantees there are no loops
- [ ] Another interesting unanswered question: is it important for this framework to be able to handle state-change-induced state changes?
  - Example: a component is added. It then becomes focused straight away. If the focus is maintained at the top level, how does the _resolution_ of a change in state propagate through to then make its own change in the state?
  - A naive solution would be to say that whichever change actually prompted the state change should also have set the focus, but this is shortsighted: it potentially had no way of knowing what the focus should be set to
  - Then again, the beauty of having the whole tree at your disposal is that it might be possible to easily identify - and surgically manipulate - other parts of the tree, even though they're in entirely separate branches
- Note that each value in the context needs to come with some indication of where it came from
  - Ie. if a component depends on a value from the context, upon which path should it then depend?
- [ ] Need to work out which problem this whole thing actually solves
  - Ie. what are the guiding principles of this system?
- Thoughts on more concrete data representations:
  - Paths should be represented as referenceable objects, which contain a path and the most up-to-date state object
    - Each component could be passed its workspace as a path, which reduces the amount of information you need to pass to the update function in order to let the component know where it "lives"
    - It also makes it easier to get the initial "pointer" to pass to any children - ie. you can just extend the pointer you've been given for your workspace
    - ~~Something else here I've forgotten...~~ You can then return a bunch of these objects from the child when it's been run (or, better yet, store them as a member of the child's workspace) and join them all together to be sent up to the next level
    - Possible name for these objects: "entities". This makes sense as they refer to a particular part of the state
  - How about representing the context as a bundle of entities as well?
    - I don't see why not
    - It gets a bit more complicated in two scenarios I can think of:
      - Derived context that isn't necessarily stored anywhere, like the updated bounds passed on by a translate component
      - Global state that's stored in the context, and for which a more deeply nested part is then accessed
    - Both of the above concerns can be solved by making entities a bit more like a traditional observable, but making them stateless; ie. instead of always just maintaining a path, they can be asked to return a set of dependent paths
      - The above scenarios are solved as:
        - Derived entities can simply refer to the original entities from which they were derived
        - Global state, if stored in an entity, can simply have a cursor called on it (as any other ~~piece of state~~ entity would) to select only the part that's actually used as a dependency
      - Ultimately I suppose these should have test cases that run for them
- [ ] Should the default interface have `update` return a set of changed paths within the workspace?
  - This might be useful for avoiding further recomputation in the parent if a particular object hasn't been altered
  - On the other hand, it might be an enormous faff for not much gain at all
  - ==> Let's not do it like that for now, and revisit later if optimisation proves that's actually a bottleneck
- Thoughts on optimising the path intersection algorithm:
  - The chances are that it doesn't need to be optimised for a while
  - By far the most common operation will be taking two sets of entities - one representing changes and one dependencies - and working out whether they "overlap"
    - In this context, overlapping means that they don't diverge. So, `[:a :b]` overlaps with both `[:a]` and `[:a :b :c]`, but not `[:a :c]`
  - A set of paths can be reduced to a nested map; the leaves would just be any non-map object. So the set of paths `#{[:a :b]}` would be represented as `{:a {:b true}}`
    - [ ] When reducing sets that have overlapping paths (`#{[:a :b :c] [:a :b]}`) I think it's fine to just take the longer one? So this would reduce to `{:a {:b {:c true}}}`
  - Comparing two nested maps then becomes a simple recursive operation:
    - Find the intersection of their keys
    - If the intersection is empty, there's no overlap
    - For each joined key, compare the two corresponding values
      - If either is `true`, there's an overlap
      - Otherwise, you have two maps, and can apply the algorithm recursively again
  - I think this algorithm would work and exit early most of the time?
- Possible interface for higher-level (ie. unoptimised) components:

  ```clojure
  (defcomponent example
    [a "Must be passed as an argument"
     b (default 10) "Will default to `10` if not passed"
     c (context :state :cache 1) "Derives its value from the component's context"
     d (context :mouse) (default [0 0]) "Derived from the context, or just a default"
     e (state (+ a c)) "Track value as locally managed state if not otherwise provided"]

    bounds
    (if-let [[mouse-x mouse-y] d]
      [(* mouse-x 2) (* mouse-y 2)]
      [100 100])

    render
    (rectangle bounds [0.2 0.6 0.7]))
  ```

  - Calling this component would look like `(example 1 :c 2)`
  - The body of the component is specified as a bunch of key-value pairs, where each key maps to the form that will be evaluated to determine its result
  - Only the requested results will be evaluated, meaning some components will be able to provide a quicker return if eg. only their bounds are requested, and not the render
  - If there are an odd number of forms, the odd one out will have its results used instead of any that are not specified
    - That way it's also allowed to simply call some of the lower-level components, but override one or two of the resulting values
  - Each argument would get passed as an entity that can be referenced
    - Technically some of them can also be set, though that should only really be happening in callbacks (ie. updating the state shouldn't really trigger more changes to the state)
  - [ ] How will this deal with splatted arguments?
    - One option: separate the passed arguments and context-derived arguments
      - I don't like this as it would be incredibly powerful to be able to sometimes specify arguments and sometimes let the component handle them itself
    - Another option: introduce some special notation for it
      - This is difficult as then questions are raised about how to bind those values in the presence or absence of other optional arguments
        - We do need to solve this problem anyway, though, so it might still be fine
  - [ ] Is the setup here actually enough to just define all the lower-level components outright?

- [ ] Which lower-level components do we need to make a system for building user interfaces?
- Having thought about this a bit more, I reckon there is actually a concise and elegant solution for this kind of problem
  - To rehash the problem: we would like to come up with some kind of data structure (an "entity") that can manage its value, as a piece of state, efficiently with respect to external changes to some part of it
    - This is similar to a typical observer model, but adopts an extremely top-down approach
    - Any data structure should be able to be an entity, probably by tagging it with some kind of metadata containing its handler
  - Should entities need to respond to changes globally - in some outer entity - or only those within their scope?
    - It's probably easier for everyone involved if we limit it to changes within the scope. Then the top-down approach works better as you don't need to assume some kind of global state; you need only know about things that have been passed to you explicitly
  - So the interface should look something like this: an entity takes a set of internal, local, and global scopes, and transforms them into a new set of scopes
    - The internal scope is the state maintained by the entity itself. This may be any collection, but is assumed to be a map, and may be tagged with a list of "paths" whose values have been deemed to change. This will come from some external source
      - Note that **changes will not have been applied already**; these could probably be considered to be "requests" rather than "notifications" and, as such, should probably map to the new values
    - The local scope is the set of arguments passed to the entity. It will typically be a vector of values
      - I'm a little skeptical of the exact place the arguments hold in the whole system. I do think it's necessary, as we want to pass some values down without their necessarily being tracked by the state internally. We may also not want them to be passed down to children by default, which is the purpose of the global context/scope
        - As a side note, it seems that a lot of problems actually resolve down to this issue of assumed context: see, for example, building up modules with assumed imports; or defining patterns that always assume they're operating on a single value. One to put more thought into...
        - Semantically, arguments/local scope could also be justified as representing values which, if changed, don't automatically propagate down to children
          - For example, a change in the theme (in the global scope) may affect children even if the immediately-called entity doesn't consume the theme itself
      - Arguments will typically not be annotated with changed paths, though I suppose I don't see why that shouldn't be possible
        - Perhaps, when looking at changed paths, we should consider a `nil` value to mean that everything has changed, and a rerun is necessary. Whereas an empty vector/map would mean that we have verified nothing has changed
    - The global scope is a context containing values made available to the entity. The entity is notified of changes in the global scope, rather than having them requested; they have already been made and it must update its state accordingly
      - This will typically be presented as a map, with metadata indicating a set of paths that have been updated
        - Note that paths are defined as per `get-in`
        - These are included in the metadata rather than in the object themselves to denote the fact that they are temporary
  - Note that the internal scope, local scope, and global scope could equally be referred to as the state, arguments, and context respectively
  - The fairly general nature of entities means they can be easily composed and chained together, with one entity modifying the various scopes before passing them onto the next one
    - Once they've all completed, it's probably only the state/internal scope that you're interested in
      - This presents itself quite well to having lazy parameters, I think, as it could simply contain keys that map to functions instead of values
  - For the sake of improved visibility it's probably best if, at least by convention, values are stored in the entity's state (albeit under scoped keys) rather than in the metadata
- Examples of some common entities that could be useful in building up more complex ones:
  - [ ] `(q/state 'identifier (q/default ,,,))`
    - Defines a new piece of state maintained in the workspace (alternate and less confusing name for state/internal scope) under `[::state 'identifier]`
    - This should add a dependency of itself to `[::dependencies]` in the workspace
    - If its dependency has changed, it should set `[::state 'identifier]` to the corresponding value; otherwise if the value is missing it should set it to the default (which itself could be an entity to allow it to be derived from, say, the context or from other properties of the enclosing entity); otherwise it should be left alone
    - I suppose it would also be fine if you were to store this under `['identifier]` directly, as local state isn't special in this system as it is in something like react. That would increase interoperability with other entities, allowing it to be treated as any old standard property
  - [ ] `(q/cache entity)`, or perhaps `(q/guard entity)`
    - Stores the arguments under `[::arguments]`
    - Before doing that, if there are no changes to the arguments (obtained by direct comparison with the old ones), no changes to the state (the count of its changes is zero), and no changes to the context (the count of its changes is zero), returns the entity as-is
    - This will likely be a common wrapper used to prevent needless re-evaluations of entities
    - You could also return the current value immediately, presumably, if `::dependencies` is defined on the entity and it has no overlaps with the changes in the context or workspace
      - (Although I have just realised that this new system means you probably need to track state dependencies and context dependencies separately)
  - [ ] `(q/child entity :key)`
    - This one will have a lot of different purposes and probably be quite complex
    - It's essentially used to have the state of a child entity automatically managed
    - Children will have to live under `[::children key]`, where `key` is the key of that child
    - When this is called, it will add to the map of children a workspace under the relevant key, where the workspace is generated by calling the handler of `entity` along with the arguments of `entity`, the current context, and the child's current workspace
      - The current workspace will be obtained from the map of children, or passed as an empty map if the child does not exist yet
      - Note that this implies that `entity` contains both a handler and set of arguments, which will be a common pattern and should be handled at the library level
    - It's possible for the key to be generated automatically
      - For this to happen, any calls to `q/child` should be wrapped in `q/children`.  This will set up a `[::children ::key]` property, which is initially `0`, and is accessed by `q/child` and incremented as it goes along
      - It (`q/children`) can also, before updating its wrapped entity, take note of the children that currently exist.  Then, after updating has completed, any children that didn't get updates in that round can be pruned
  - [ ] `(q/get child? [path])`
    - Returns the current value of the path of the current entity
    - Could this be made to work on child entities, if it's given one as an argument?
    - This could also be made to work with lazy and/or cached properties
      - If the property is marked - via metadata - as lazy, its function should be called and returned instead
      - If it's also marked as cached - again, via metadata - the function should called and then replaced with its result, in the workspace of the passed entity, before being returned
  - [ ] `(q/provide key value entity)`
    - Set a value in the scope before passing it to the child entity
    - Dependency management here might be a bit tricky ... an open question
    - [x] How does it work in combination with state, when you want to use it like a store?
      - We already know whether the state has been updated, therefore the provider can pass that through into the list of context changes
      - In the case that the provided value is derived, you can either compare it to the last value or work out the dependencies of the derived value somehow
        - Eg. `(q/derive translate (q/consume :mouse))`
        - ~~`q/resolve`~~ `q/get` could probably be made to update its return values' dependencies in some clever way such that this will always work
- [ ] When returning an entity, would it be possible to track the paths of all entities inside it?
  - Then it would be possible to skip updating all entities in a chain between two others, if you can see in advance that the next changed value in the state sits inside a deeply-nested entity
    - That would make it difficult to update ones in between based on any results in the deeply-nested child that update as a result, however
      - I'm sure there's a solution to this, though; you have the entire data structure at your disposal so I'm sure it'd be possible to work something out
- [ ] If we want to handle mouse actions by simply passing in a change to the context, for example, it will actually be necessary to be able to raise events from inside the entity
  - This raises a much more fundamental question: how are side effects propagated back up the tree?
  - Simplest possible way: use the returned context as a sort of accumulator
    - This *feels* a bit off but I can't see any actual problems with it
    - With this method you could even have the handler at the top level: use a simple `q/on-change` wrapper, and if there are any values in the returned context's `::on-change` property, update the child entity again with those new paths in the list of changed dependencies
    - Problem is that then every other entity needs to know about this, so it can merge the side effects
- This new system, where there's no global object and you just respond to whatever gets passed down through the context, is nice: it means the top-level caller can simply send in a context with eg. a new mouse position, or list of depressed keys
- Now it's time to think about how all of this is going to be laid out in an implementation
  - Perhaps good to contextualise this with an incredibly simple widget
    - Consider, for example, a couple of coloured rectangles rendered one on top of the other.  Clicking one will set its colour to some random RGB value
  - Probably fine to just start with a big list of entities, defined as records implementing a protocol
    - No need to work out how to instantiate them easily just yet, as that will presumably ~~all~~ mostly be done by macros anyway
  - First problem I've run into is this thing about whether the context dependencies need to be treated differently to the workspace dependencies
    - I'm pretty sure they do, because the nature of how those things are passed is fundamentally different
    - When "unrolling" the tree, after the application of an entity, the workspace dependencies need to have segments added to their paths.  Context dependencies don't; in fact, at some stage (eg. in `q/provide`) they may need to be converted from context dependencies to workspace dependencies
    - How should this be handled?
      - Have a `::dependencies` key, whose mapping contains a different set for each type of dependency (`:context`, `:arguments`, and `:workspace`)
      - Each can be handled differently by whatever's calling it
      - This also leaves room in the future for other types of dependencies.  For example, when implementing animations, it might make sense for there to be a `:time` dependency a la trickle
  - An example of where this matters is in `q/consume`
    - The resulting entity has had its workspace modified according to the content of the context; so if that part of the context changed, it will also have changed in the workspace now
    - Likewise, if the child entity depends on that key in the workspace, this entity should now depend on the corresponding key in the workspace
    - For these changes to take effect, entities need to have control over how their children are executed
- The more time I spend thinking about this, the more I feel it would just be so much easier in Parsle
- Something else that's cool about this system is that, because you have complete control over when things get cached or not, you can only cache (guard?) certain subsections of an entity
