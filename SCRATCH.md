- A component is given a completely unregulated "workspace"
- When some part of the global workspace changes, the component is asked to update its workspace
- The function for doing this looks something like `(update [workspace context arguments paths-in paths-out] ...)`
- This extremely general wrapper should allow you to write heavily optimised components if you really want to
- Most typical components should - hopefully - become quite simple under this paradigm
- We could impose some structure upon the returned workspace to standardise some common optimisations
- For example, if the workspace always contains `:arguments`, `:state`, and `:consumed` forms, and there's no global state (only provided state), you know that you don't need to do any updates at all if:
  - All arguments are the same
  - All of your consumed paths, and those of your children, diverge from all of the updated paths
    - Is this horrendously difficult to check, computationally?
    - Because there'll probably be lots of nice branching behaviour, seems like it'd be pretty easy to check if we really wanted to find an optimised way of writing it (with some custom algorithm)
  - Also, at each stage you can cull the dictionary of changed paths according to the dictionary of consumed paths, which makes future checks (further down the line) easier
- The output of the update method should be a series of path-value pairs, which are used by the framework to update its state atom externally
  - This also means that callers of child components can determine whether or not they need to update any of their keys, or whether they can just return the update as-is
- Another nice thing is that the entire tree - including all globally- and locally-managed state - can be viewed as a single clojure object, with no extra bells or whistles
- Finally, it would be easy to come up with some heuristic to work out when to "collapse" the tree of dependencies
  - Eg. if a component is listening to the paths `[:state :text]`, `[:state :history :1]`, and `[:state :start]`, it might make sense to collapse that to just `[:state]` to reduce the complexity of checks
  - If you wanted to impose a little more structure, you could say that you're going to represent paths with two components: the component path and the state path. Then you'd know that you don't ever need to consider any updates that have diverging component paths, since there's no way for a component to affect another that isn't in the same branch
    - Though I don't like this as much because it's kind of cool that the state of a children of a component exist exclusively inside its workspace, and aren't in any way special; they're the same as any other state in the tree
- Obviously you'd need a bunch of wrappers around all of this to make it usable anyway
- Another cool thing is that you really can go all the way on the "events as state" train, even for impulse events like clicks and key presses
  - You'd just make sure there's a "key press" path, and every time it gets an updated signal you assume its current value is the key pressed
  - To save on rendering time, if multiple come through at once you could send down the events without a `:render` request in the `paths-out`, so highly-optimised components could even avoid rendering themselves until actually requested if they really wanted to
  - One important convention for this to actually work: any values of `nil` in the returned mapping (paths out) must always be interpreted as "computed lazily; must be requested specifically to obtain a value"
- [ ] A conundrum: if the mouse position is to be constantly in the state, and always updated, it mustn't trigger spurious updates whenever it moves
  - This means that components need to be able to say whether they use the mouse status, to prevent common components like `translate` from having to continually update the mouse position when their children are uninterested in the mouse position
  - Crucially, you need to know whether to compute the new translated mouse position before rendering any children (as you need to build the context); but you don't know whether or not the child is consuming the mouse position until after it's been rendered - and hence until after you've already computed the new position
  - I'm sure you could probably come up with a contrived example where the child becomes dependent on the mouse position suddenly, as a result of a change in some other variable
    - Actually I don't even think it would need to be all that contrived...
  - [ ] Are lazy contexts the way to solve this?
    - Importantly: while I suspect it's possible for a child component to start caring about whether the mouse position _will change_ spontaneously, I don't think it's possible for it to suddenly start caring about whether it _has changed_, since it didn't know what the previous value was in the first place
- It's interesting to note that literally none of this is UI-specific - at least, not in its most general case
  - Surely this is reinventing some wheel somewhere?
  - I suppose what it really is is a way of laying out the classic observer architecture in a way that (sort of?) guarantees there are no loops
- [ ] Another interesting unanswered question: is it important for this framework to be able to handle state-change-induced state changes?
  - Example: a component is added. It then becomes focused straight away. If the focus is maintained at the top level, how does the _resolution_ of a change in state propagate through to then make its own change in the state?
  - A naive solution would be to say that whichever change actually prompted the state change should also have set the focus, but this is shortsighted: it potentially had no way of knowing what the focus should be set to
  - Then again, the beauty of having the whole tree at your disposal is that it might be possible to easily identify - and surgically manipulate - other parts of the tree, even though they're in entirely separate branches
- Note that each value in the context needs to come with some indication of where it came from
  - Ie. if a component depends on a value from the context, upon which path should it then depend?
- [ ] Need to work out which problem this whole thing actually solves
  - Ie. what are the guiding principles of this system?
- Thoughts on more concrete data representations:
  - Paths should be represented as referenceable objects, which contain a path and the most up-to-date state object
    - Each component could be passed its workspace as a path, which reduces the amount of information you need to pass to the update function in order to let the component know where it "lives"
    - It also makes it easier to get the initial "pointer" to pass to any children - ie. you can just extend the pointer you've been given for your workspace
    - ~~Something else here I've forgotten...~~ You can then return a bunch of these objects from the child when it's been run (or, better yet, store them as a member of the child's workspace) and join them all together to be sent up to the next level
    - Possible name for these objects: "entities". This makes sense as they refer to a particular part of the state
  - How about representing the context as a bundle of entities as well?
    - I don't see why not
    - It gets a bit more complicated in two scenarios I can think of:
      - Derived context that isn't necessarily stored anywhere, like the updated bounds passed on by a translate component
      - Global state that's stored in the context, and for which a more deeply nested part is then accessed
    - Both of the above concerns can be solved by making entities a bit more like a traditional observable, but making them stateless; ie. instead of always just maintaining a path, they can be asked to return a set of dependent paths
      - The above scenarios are solved as:
        - Derived entities can simply refer to the original entities from which they were derived
        - Global state, if stored in an entity, can simply have a cursor called on it (as any other ~~piece of state~~ entity would) to select only the part that's actually used as a dependency
      - Ultimately I suppose these should have test cases that run for them
- [ ] Should the default interface have `update` return a set of changed paths within the workspace?
  - This might be useful for avoiding further recomputation in the parent if a particular object hasn't been altered
  - On the other hand, it might be an enormous faff for not much gain at all
  - ==> Let's not do it like that for now, and revisit later if optimisation proves that's actually a bottleneck
- Thoughts on optimising the path intersection algorithm:
  - The chances are that it doesn't need to be optimised for a while
  - By far the most common operation will be taking two sets of entities - one representing changes and one dependencies - and working out whether they "overlap"
    - In this context, overlapping means that they don't diverge. So, `[:a :b]` overlaps with both `[:a]` and `[:a :b :c]`, but not `[:a :c]`
  - A set of paths can be reduced to a nested map; the leaves would just be any non-map object. So the set of paths `#{[:a :b]}` would be represented as `{:a {:b true}}`
    - [ ] When reducing sets that have overlapping paths (`#{[:a :b :c] [:a :b]}`) I think it's fine to just take the longer one? So this would reduce to `{:a {:b {:c true}}}`
  - Comparing two nested maps then becomes a simple recursive operation:
    - Find the intersection of their keys
    - If the intersection is empty, there's no overlap
    - For each joined key, compare the two corresponding values
      - If either is `true`, there's an overlap
      - Otherwise, you have two maps, and can apply the algorithm recursively again
  - I think this algorithm would work and exit early most of the time?
- Possible interface for higher-level (ie. unoptimised) components:

  ```clojure
  (defcomponent example
    [a "Must be passed as an argument"
     b (default 10) "Will default to `10` if not passed"
     c (context :state :cache 1) "Derives its value from the component's context"
     d (context :mouse) (default [0 0]) "Derived from the context, or just a default"
     e (state (+ a c)) "Track value as locally managed state if not otherwise provided"]

    bounds
    (if-let [[mouse-x mouse-y] d]
      [(* mouse-x 2) (* mouse-y 2)]
      [100 100])

    render
    (rectangle bounds [0.2 0.6 0.7]))
  ```

  - Calling this component would look like `(example 1 :c 2)`
  - The body of the component is specified as a bunch of key-value pairs, where each key maps to the form that will be evaluated to determine its result
  - Only the requested results will be evaluated, meaning some components will be able to provide a quicker return if eg. only their bounds are requested, and not the render
  - If there are an odd number of forms, the odd one out will have its results used instead of any that are not specified
    - That way it's also allowed to simply call some of the lower-level components, but override one or two of the resulting values
  - Each argument would get passed as an entity that can be referenced
    - Technically some of them can also be set, though that should only really be happening in callbacks (ie. updating the state shouldn't really trigger more changes to the state)
  - [ ] How will this deal with splatted arguments?
    - One option: separate the passed arguments and context-derived arguments
      - I don't like this as it would be incredibly powerful to be able to sometimes specify arguments and sometimes let the component handle them itself
    - Another option: introduce some special notation for it
      - This is difficult as then questions are raised about how to bind those values in the presence or absence of other optional arguments
        - We do need to solve this problem anyway, though, so it might still be fine
  - [ ] Is the setup here actually enough to just define all the lower-level components outright?

- [ ] Which lower-level components do we need to make a system for building user interfaces?
- Having thought about this a bit more, I reckon there is actually a concise and elegant solution for this kind of problem
  - To rehash the problem: we would like to come up with some kind of data structure (an "entity") that can manage its value, as a piece of state, efficiently with respect to external changes to some part of it
    - This is similar to a typical observer model, but adopts an extremely top-down approach
    - Any data structure should be able to be an entity, probably by tagging it with some kind of metadata containing its handler
  - Should entities need to respond to changes globally - in some outer entity - or only those within their scope?
    - It's probably easier for everyone involved if we limit it to changes within the scope. Then the top-down approach works better as you don't need to assume some kind of global state; you need only know about things that have been passed to you explicitly
  - So the interface should look something like this: an entity takes a set of internal, local, and global scopes, and transforms them into a new set of scopes
    - The internal scope is the state maintained by the entity itself. This may be any collection, but is assumed to be a map, and may be tagged with a list of "paths" whose values have been deemed to change. This will come from some external source
      - Note that **changes will not have been applied already**; these could probably be considered to be "requests" rather than "notifications" and, as such, should probably map to the new values
    - The local scope is the set of arguments passed to the entity. It will typically be a vector of values
      - I'm a little skeptical of the exact place the arguments hold in the whole system. I do think it's necessary, as we want to pass some values down without their necessarily being tracked by the state internally. We may also not want them to be passed down to children by default, which is the purpose of the global context/scope
        - As a side note, it seems that a lot of problems actually resolve down to this issue of assumed context: see, for example, building up modules with assumed imports; or defining patterns that always assume they're operating on a single value. One to put more thought into...
        - Semantically, arguments/local scope could also be justified as representing values which, if changed, don't automatically propagate down to children
          - For example, a change in the theme (in the global scope) may affect children even if the immediately-called entity doesn't consume the theme itself
      - Arguments will typically not be annotated with changed paths, though I suppose I don't see why that shouldn't be possible
        - Perhaps, when looking at changed paths, we should consider a `nil` value to mean that everything has changed, and a rerun is necessary. Whereas an empty vector/map would mean that we have verified nothing has changed
    - The global scope is a context containing values made available to the entity. The entity is notified of changes in the global scope, rather than having them requested; they have already been made and it must update its state accordingly
      - This will typically be presented as a map, with metadata indicating a set of paths that have been updated
        - Note that paths are defined as per `get-in`
        - These are included in the metadata rather than in the object themselves to denote the fact that they are temporary
  - Note that the internal scope, local scope, and global scope could equally be referred to as the state, arguments, and context respectively
  - The fairly general nature of entities means they can be easily composed and chained together, with one entity modifying the various scopes before passing them onto the next one
    - Once they've all completed, it's probably only the state/internal scope that you're interested in
      - This presents itself quite well to having lazy parameters, I think, as it could simply contain keys that map to functions instead of values
  - For the sake of improved visibility it's probably best if, at least by convention, values are stored in the entity's state (albeit under scoped keys) rather than in the metadata
- Examples of some common entities that could be useful in building up more complex ones:
  - [ ] `(q/state 'identifier (q/default ,,,))`
    - Defines a new piece of state maintained in the workspace (alternate and less confusing name for state/internal scope) under `[::state 'identifier]`
    - This should add a dependency of itself to `[::dependencies]` in the workspace
    - If its dependency has changed, it should set `[::state 'identifier]` to the corresponding value; otherwise if the value is missing it should set it to the default (which itself could be an entity to allow it to be derived from, say, the context or from other properties of the enclosing entity); otherwise it should be left alone
    - I suppose it would also be fine if you were to store this under `['identifier]` directly, as local state isn't special in this system as it is in something like react. That would increase interoperability with other entities, allowing it to be treated as any old standard property
  - [ ] `(q/cache entity)`, or perhaps `(q/guard entity)`
    - Stores the arguments under `[::arguments]`
    - Before doing that, if there are no changes to the arguments (obtained by direct comparison with the old ones), no changes to the state (the count of its changes is zero), and no changes to the context (the count of its changes is zero), returns the entity as-is
    - This will likely be a common wrapper used to prevent needless re-evaluations of entities
    - You could also return the current value immediately, presumably, if `::dependencies` is defined on the entity and it has no overlaps with the changes in the context or workspace
      - (Although I have just realised that this new system means you probably need to track state dependencies and context dependencies separately)
  - [ ] `(q/child entity :key)`
    - This one will have a lot of different purposes and probably be quite complex
    - It's essentially used to have the state of a child entity automatically managed
    - Children will have to live under `[::children key]`, where `key` is the key of that child
    - When this is called, it will add to the map of children a workspace under the relevant key, where the workspace is generated by calling the handler of `entity` along with the arguments of `entity`, the current context, and the child's current workspace
      - The current workspace will be obtained from the map of children, or passed as an empty map if the child does not exist yet
      - Note that this implies that `entity` contains both a handler and set of arguments, which will be a common pattern and should be handled at the library level
    - It's possible for the key to be generated automatically
      - For this to happen, any calls to `q/child` should be wrapped in `q/children`. This will set up a `[::children ::key]` property, which is initially `0`, and is accessed by `q/child` and incremented as it goes along
      - It (`q/children`) can also, before updating its wrapped entity, take note of the children that currently exist. Then, after updating has completed, any children that didn't get updates in that round can be pruned
  - [ ] `(q/get child? [path])`
    - Returns the current value of the path of the current entity
    - Could this be made to work on child entities, if it's given one as an argument?
    - This could also be made to work with lazy and/or cached properties
      - If the property is marked - via metadata - as lazy, its function should be called and returned instead
      - If it's also marked as cached - again, via metadata - the function should called and then replaced with its result, in the workspace of the passed entity, before being returned
  - [ ] `(q/provide key value entity)`
    - Set a value in the scope before passing it to the child entity
    - Dependency management here might be a bit tricky ... an open question
    - [x] How does it work in combination with state, when you want to use it like a store?
      - We already know whether the state has been updated, therefore the provider can pass that through into the list of context changes
      - In the case that the provided value is derived, you can either compare it to the last value or work out the dependencies of the derived value somehow
        - Eg. `(q/derive translate (q/consume :mouse))`
        - ~~`q/resolve`~~ `q/get` could probably be made to update its return values' dependencies in some clever way such that this will always work
- [ ] When returning an entity, would it be possible to track the paths of all entities inside it?
  - Then it would be possible to skip updating all entities in a chain between two others, if you can see in advance that the next changed value in the state sits inside a deeply-nested entity
    - That would make it difficult to update ones in between based on any results in the deeply-nested child that update as a result, however
      - I'm sure there's a solution to this, though; you have the entire data structure at your disposal so I'm sure it'd be possible to work something out
- [ ] If we want to handle mouse actions by simply passing in a change to the context, for example, it will actually be necessary to be able to raise events from inside the entity
  - This raises a much more fundamental question: how are side effects propagated back up the tree?
  - Simplest possible way: use the returned context as a sort of accumulator
    - This _feels_ a bit off but I can't see any actual problems with it
    - With this method you could even have the handler at the top level: use a simple `q/on-change` wrapper, and if there are any values in the returned context's `::on-change` property, update the child entity again with those new paths in the list of changed dependencies
    - Problem is that then every other entity needs to know about this, so it can merge the side effects
- This new system, where there's no global object and you just respond to whatever gets passed down through the context, is nice: it means the top-level caller can simply send in a context with eg. a new mouse position, or list of depressed keys
- Now it's time to think about how all of this is going to be laid out in an implementation
  - Perhaps good to contextualise this with an incredibly simple widget
    - Consider, for example, a couple of coloured rectangles rendered one on top of the other. Clicking one will set its colour to some random RGB value
  - Probably fine to just start with a big list of entities, defined as records implementing a protocol
    - No need to work out how to instantiate them easily just yet, as that will presumably ~~all~~ mostly be done by macros anyway
  - First problem I've run into is this thing about whether the context dependencies need to be treated differently to the workspace dependencies
    - I'm pretty sure they do, because the nature of how those things are passed is fundamentally different
    - When "unrolling" the tree, after the application of an entity, the workspace dependencies need to have segments added to their paths. Context dependencies don't; in fact, at some stage (eg. in `q/provide`) they may need to be converted from context dependencies to workspace dependencies
    - How should this be handled?
      - Have a `::dependencies` key, whose mapping contains a different set for each type of dependency (`:context`, `:arguments`, and `:workspace`)
      - Each can be handled differently by whatever's calling it
      - This also leaves room in the future for other types of dependencies. For example, when implementing animations, it might make sense for there to be a `:time` dependency a la trickle
  - An example of where this matters is in `q/consume`
    - The resulting entity has had its workspace modified according to the content of the context; so if that part of the context changed, it will also have changed in the workspace now
    - Likewise, if the child entity depends on that key in the workspace, this entity should now depend on the corresponding key in the workspace
    - For these changes to take effect, entities need to have control over how their children are executed
- The more time I spend thinking about this, the more I feel it would just be so much easier in Parsle
- Something else that's cool about this system is that, because you have complete control over when things get cached or not, you can only cache (guard?) certain subsections of an entity
- Perhaps time to think about this from a slightly different angle again
  - We ultimately want to have a nested data structure within which certain rules always hold. For example, the data structure could be `{:a 1 :b 2 :c 3}`, where `c` is always the sum of `a` and `b`
    - The data structure has some metadata that describes how it should be updated when changes happen. It is notified of changes by some map, mapping paths within it to their new value. It must then apply those changes, and any resulting changes, and return the new object
    - How might this example be represented? Could be something like `{:a (state) :b (state) :c (derived sum :a :b)}`
      - This object should know that it needs to listen for changes to the paths `[:a]` and `[:b]`
- I do think that kind of thought experiment is a good place to start
  - Especially since it's devoid of any kind of UI context
  - Just define an entity as some function which, given a set of local arguments and global context, returns some value along with a list/set of dependencies
- What should the interface look like?
  - `(q/map [a (q/state 0) b (q/state 0) c (+ @a @b)])`
- After further consideration, it makes sense to bundle all the different bits of state together

  - When called, a component/entity gets a single object, containing: under `:context`, a map of values passed down to it from potentially much further up the call stack; under `:arguments`, a vector (typically) of values pertaining exclusively to it; under `:scope`, a workspace containing values that will not be persisted beyond this run; and under `:state`, the previous value returned from this entity (which will always be `nil` if it has not yet been called)

    - It will also receive, alongside this object, a set of paths within that object that have changed since the last time it was called
      - If it's being called for the first time, that set may well be `#{[]}` - ie. everything has changed
      - Note that changes to the internal state will already have been applied to it; it's now simply being asked to respond to them if necessary
    - A key thing to understand is that there's a distinction between what I'm calling, for lack of a better term, "static" and "dynamic" arguments

      - Static arguments are always fixed, and are sort of compile-time constants. They should be built into the entity definition. These might include things like the name of the variable being consumed from the context
      - Dynamic arguments are ones that might update each time the entity is called, and are hence stored in the inputs and have the ability to change. A better - more react-like - name for these might be "props". These are supplied via direct passing to a `q/child` form

        - This closes off a big hole in my understanding up until now. These are genuinely two different concepts, each useful in its own right. It's also important to note that this means that calls to `q/child` are a meaningful delineation between different parts of the object

          - But this does make sense, as it's often necessary for eg. the scope to be shared among multiple calls, even though it's supposedly "local"

            - The key insight here is that it's local to the _component_, but not necessarily local to the _entity_
            - For example, to achieve something like `(defcomponent text [colour (context primary-colour) (state [0 0 0])] ,,,)`, the `context` and `state` forms might conceivably both need to access the same scope

              - (As a side point, each argument in that form should start with an implicit `(argument index)`)

                - The full form, when formatted, might look something like:

                  ```clojure
                  (q/defcomponent text-field
                    [text (state "")
                     colour (context :text-colour)
                            (state [0 0 0])
                     selection (state {:start 0 :end 0})
                     history (state [])]
                    (q/stack (q/paragraph text)
                             ,,,))
                  ```

- Two values should then be returned
  - The first is simply the new state value of the entity/component
  - The second is a set of dependencies which, if any of them change, this entity would like to be informed of
  - The entity does not need to return a list of values that have changed. This is because the caller knows if it needs to check whether any of the resulting values have changed, and has both the old and new values at this point; so it can perform the check itself
    - Performing that check will also be pretty cheap in clojure
- With all of the above in mind, what are the most basic entities needed to start building up more complex components?
  - [x] `cache`
    - Could also be called `guard`
      - These may actually be slightly different things. Caching would prevent a component from being rerun if none if its dependencies have changed, whereas guarding would watch a value and remove it from the list of changed values if - even though its source has said it may have changed - its actual value is the same
        - This would be useful when eg. translating a mouse position that actually is required, but it can be stored as `nil` when it's outside a component and so doesn't actually change in the majority of cases
        - Likewise it may be useful after deriving a boolean from a complex value or something like that
    - Stores the returned dependencies of its child (perhaps as metadata?), and only executes the child again if any of the dependencies have changed
    - This one is particularly important because it frees up other entities to not worry so much about changes when they don't need to
      - The idea is you can just wrap your entire eg. component in a cache, and then other entities inside its implementation don't need to worry about checking whether or not they should execute. They just do the work
        - For example, `property` calls don't need to check whether their dependencies have changed. The
        - Specifically, dependencies only need to be _registered_ instead of being _propagated_. Only a small number of entities - like `provide` - will need to actually propagate/transform their dependencies
    - This does mean that the resulting value would be returned wrapped in some kind of map containing dependencies and value
      - In fact it would just be the exact same format as the returned value
      - It's a bit difficult that this needs to use the `:state` since it's not really given its own thing - how do we know that it's going to be passed the correct internal state by the caller?
        - Ultimately I suppose we don't - just need to trust the other observers to be defined properly
      - In practice it may have to be done with metadata as it's not necessarily reasonable to expect every caller to know whether or not they need to unpack the value to obtain eg. a render object
        - Another way of doing this would be to just add a key to the returned value
          - To prevent conflicts this could be overridden
        - Either way, a wrapped value isn't good enough as it goes against the notion of a referentially transparent cache; you shouldn't need to know whether or not the observer you're calling is being cached to use it
  - [x] `context`
    - Grabs a value from a particular path in the context, and returns it along with the required dependency
    - For the low-level observers, this has been merged into `Lookup`
  - [x] `provide`
    - Copies a value - which could be determined from some passed entity - into the context. Then calls a child entity
    - [x] What should it list its dependencies as?
    - [x] How should it determine whether or not its value has changed?
    - [x] How can we escape doing work if its value isn't required by any children?
      - Prime example here is having a `translate` UI component that transforms the mouse positions; but should avoid doing that work if not strictly necessary
      - Doesn't need to actually provide the value if, on the last render, the child didn't depend on it
        - I don't think it should be possible (?) for a child to suddenly require an entirely new property without having checked it before
          - Actually I can think of a few nasty edge cases. Perhaps best to come back to this one later
        - Would lazy providers do the trick?
        - In fact, _given that the provider is being called_ it makes sense to just compute the new value and send it forward. If it's being called, it's because the child needed it somehow. If the child doesn't need it, after the first render, the child won't list that as a dependency; then this doesn't need to return any dependencies and the whole thing won't be re-rendered next time
          - But _if it does get rendered_ it should compute and send the value
          - Again, a robust test case is needed to check whether this intuition holds
    - For the low-level observers, this has been merged into `Write`
  - [x] `derived`
    - Simply computes a function of the current scope
    - Depends on the entire scope; more specific caching behaviours can be implemented if required
    - Doesn't need to call any child observers, since it's not storing the value anywhere - just computing and returning it
  - [x] `state`
    - Similar to `property` but only sets the value on the internal if it's not already defined
      - Whatever the source of the value, the value itself is returned
    - This doesn't need to listen to itself to manually update the value; that should be done externally (I think?)
      - Though a valid question is that of how it's going to pass down a swappable value
        - Perhaps this is one for the `defcomponent` macro
    - How should dependencies be handled?
      - I don't actually think this needs to export any dependencies
      - It doesn't need to be notified of any changes, since the changes will be applied to it directly and externally
      - The dependencies of the default observer from which it derives its initial value don't need to be returned, as the default observer won't be evaluated again after the state has been set initially
      - Actually I suppose it should return the path at which the state is stored as a dependency
        - Because this does both the storage and the accessing, it might be used by other observers directly, which will need to know when it may have changed
      - Really, all of this confusion just suggests that we need a more rigorous formal definition of what should be included in the dependencies: any value which, if changed, might prompt the output of this observer to also change (even if it would have been able to produce that value without knowing about the change to the observer's value)
    - How does the state both modify the current scope and return the value?
      - It probably shouldn't
        - Hence it's fine for this to not return any dependencies, and just return the value itself. The result of the state will need to be looked up independently elsewhere
          - That might be a good thing, preventing the same behaviour (lookup logic) from being implemented twice in separate locations
          - It is going to be a bit of a pain to use, though
          - An alternative would be for state to call its own child observer, but I don't think that's going to be useful to anyone
            - This might be necessary, in fact, because it needs to pass the modified scope forward to be used by another observer. This isn't possible if it simply returns the value directly (the caller wouldn't know that the returned value needs to be used to override the scope's `:state`, so this wouldn't actually be managing the state at all)
            - Final (I think) conclusion: this doesn't need to add any dependencies. If the state has changed, it will already be included in the changes passed into this. If it's being built for the first time, the child observer will end up being called with a `nil` state anyway
    - Perhaps call this `persist` instead of `state`, to solidify a verb-y naming convention
  - [ ] `children`
    - Could also be called `manage-children`, `cull`, or something like that
    - Not yet entirely sure what the purpose would be, but it feels intuitively as though something like this will be required
  - [ ] `child`
    - Could also be named `call` or `delegate`
    - Call another entity, providing it with a new scope, arguments, and potentially new state as well
    - Still need to work out how keys will work here. Calls could be stored as properties, eg. `(q/property key (q/call custom-component (q/lookup :name)))`
    - Should also be able to take a `:check #{paths}` value, in which case it will check the resulting value before storing it in the current state. If any of the checked paths have changed, they will be added to the list of changes being passed forward
      - As such I think this one will need to take a child to call afterwards
        - I suppose a convention could be made of having an optional child which, if `nil`, is not called; the results are returned directly
          - Important because I'm pretty sure I could think up reasonable uses of the `call` entity for both cases
            - Eg. it's definitely valid to want to use this as a kind of `let`, but where the call producing the bindings is an entity itself
              - Perhaps in that case what we really need is a custom `q/let` entity
                - ~~Having said that, if the child returns its state anyway then what's this really used for?~~ Checking whether or not values have changed. In that case, perhaps `watch-call` would be a better name
            - It's also valid to want to just call a child and return the value, eg. for storing in a property
    - [ ] Could this manage the arguments as well?
      - For example, if `defcomponent` were defined as wrapping something in a child, perhaps `child` could also do the work of just dumping the arguments directly into the scope - which is exactly what would be done anyway
      - It's not the end of the world if it couldn't; it'd just make everything a bit simpler if we could get rid of the arguments altogether
  - [x] `property`
    - Takes a key (path?) and another entity, computes the value of the entity, and dumps it into the state under the specified key
      - I suppose in theory the key could also be dynamically computed by an entity
        - This applies to a lot of things, really
    - Also adds the dependencies of that entity to the returned dependencies
      - This shouldn't need to be done by this observer, actually, since it's calling the child directly
        - What should really happen is that is passes an updated list of changes down to the child observer (if any of the dependencies of the exported value have changed, that exported path should be changed too). Then, if the child ends up depending on the exported path, the property dependencies should be added to the returned dependencies
          - When looking at it like this, the similarities between this and `provide` become much more apparent
    - For the verb-based naming scheme, this could instead be called ~~`export`~~ `Write`
  - [ ] `lazy-property`
    - Include a `:cache` flag for expensive calls that may be called multiple times
      - Though this shouldn't really be necessary, as that'll be handled by the caller...
    - How will this actually be handled by the caller? How does it know whether it's getting a lazy property or just a normal one?
    - This could just as easily be handled by a flag on the regular `Write`
      - The write would then be performed iff either it's an eager write, or the path is included in the list of requested paths (passed from the relevant `Call` somewhere further up in the call stack)
        - [ ] Where should export requests from calls be stored? In the workspace?
          - That probably makes sense
  - [x] `lookup`
    - Returns a value from the scope
    - Although this is technically a subset of `derived`, it's also so commonly used that storing an anonymous function in `lookup` to accomplish this might not be worth it
      - Then again, keywords do act as functions...
      - If it's decided that we don't need both, I actually think "lookup" is a better name than "derive"
      - Difference between this and `derived` is that, because it accesses a specific value, _it would be able to add that value as a dependency_
        - In this sense it has a significant overlap with `consume`
        - It's also distinguished from `derived` in the sense that that form would only pass in the workspace, as opposed to the whole scope; so it sort of forces you to unpack the values yourself via other forms; hence adding the dependencies automatically
  - [x] `argument`
    - Similar to `context`, but for the arguments list
    - Takes an integer or keyword, and grabs the corresponding one
      - I suppose technically it could just as easily do nested lookups too
    - Looks like this is going to be managed by the `Call` observer
  - [x] `chain`
    - Similar to the threading macro, but is context-aware (ie. will pass down the context/arguments/state/scope as it goes)
    - I actually think this can just be solved by the existing threading macro outright, since any observers that need to pass this context down will do it themselves
  - [x] `consume`
    - Take and return a value from a particular path in the scope
    - Also include that path in the list of dependencies
    - Perhaps include a flag that determines whether the value should be dropped from the context?
      - I don't think this would be useful; would be difficult to get it working reliably with a path instead of a single key anyway
    - [x] How is this any different from looking up a value from any other part of the passed scope?
      - It's not, really; we can
  - To start implementing the system, it should be sufficient to just start naively working through these, approximately in order
  - I also think a better name than "entity" is required - doesn't really descibe what these do very well any more
    - [x] Perhaps "observer" is fine; it's a fairly well-understood concept and, although the implementation here is slightly different to the typical one, it's still doing more or less the same thing
- Time to think a bit more about the common operations on dependencies/changes, and how they're going to be represented
  - Perhaps it'd be better to call them changes only - and get rid of dependencies as a concept - since a joint name for the two of them will be needed
    - Changes stay as they were, and dependencies become changes (that the observer needs to listen to)
  - I like the idea of storing it as a bunch of nested maps, which would allow searches to terminate early in many cases. Ie. probably better if the average operation involves comparing wide but shallow paths
  - If, however, the average operation handles a small number of deep paths, perhaps it's better to simply operate on a set?
  - For now, I'll take the simplest operation, which I think is probably the nested approach. That way you can select subsets much more easily
  - So the internal representation will be:
    - A map of segments to values
    - If the value is another map, that means there's an extension of the path
    - If instead the value is some specific value, eg. `true`, that means it's simply the end of that path
      - Perhaps a better thing to use here would be an empty map? I think that would be fine
        - This does actually work much better, as then a predicate for "has the value changed" can end in a map itself. Another consequence of this is that an empty map implies everything on that route has changed, whereas `nil` means nothing on that route has changed
  - Operations I can think of off the top of my head, which will need to be implemented:
    - [x] Convert a path - as a vector - into the internal representation
      - Decided to force this to take a sequence instead of putting it into a variable number of arguments, as I can imagine we'll end up passing paths around quite a lot and calling `apply` all the time might get old quickly
    - [x] Add a new path into a map of changes
      - Actually in the current representation there's no real distinction between a single change and a list of changes - so a better name for this would perhaps be a merge
      - There are a couple of base cases here:
        - If one of the changes is the empty map, return it (since the empty map means everything's changed, it already includes all the values of the other)
        - If one is `nil`, return the other one
      - Otherwise, we want to go through all the keys that appear in either mapping, and apply the operation recursively
        - This is where the whole "`nil` implies nothing" change really comes into its own: you can use a simple lookup across each one and it'll all work the same, all the way down
          - I'm actually really pleased with this, it's rather elegant. Treating `nil` as empty also means that, upon checking an intersection, you can treat the output as a boolean straight away without first checking whether or not it's empty
      - Implemented and seems to be working well
    - [x] Find the intersection of two change sets
      - I'm pretty sure this is a symmetrical operation? Not sure though
      - What's actually meant by this in the real world?
        - I have a set of realised changes, and a set of depended changes. I then want to know whether any of the depended changes have actually changed
        - One base case here is: I've ended up with an empty map (ie. I'm listening to all changes) and some other value representing the realised changes. There is no intersection iff the other value is `nil`
          - This may actually be symmetric: if the listened changes are `nil`, there's never an intersection
        - What about the remaining case?
          - The listened map contains some values, so you want to map through each of these, applying the function recursively to each key. But you also want to reduce the set at the end: if each key ends up being mapped to `nil`, you want to return `nil` for the whole thing
          - Other than that, seems it works quite well. I think in the end it ended up being _not_ symmetrical
      - Perhaps it's better to call this something like `changed?`
        - That makes it sound like it's returning a boolean, though, which we don't necessarily want
        - Hence a better name is `relevant-changes`
